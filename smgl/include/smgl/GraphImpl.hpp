#include "smgl/Metadata.hpp"
#include "smgl/Utilities.hpp"
#include "smgl/Uuid.hpp"

namespace smgl
{

Node::Pointer Graph::operator[](const Uuid& uuid) const
{
    auto it = nodes_.find(uuid);
    if (it != nodes_.end()) {
        return it->second;
    } else {
        throw std::invalid_argument("Node not in graph: " + uuid.string());
    }
}

void Graph::insertNode(const Node::Pointer& n) { nodes_[n->uuid()] = n; }

template <typename N, typename... Ns>
void Graph::insertNodes(N& n0, Ns&&... nodes)
{
    insertNode(n0);

    // C++11 parameter unpacking
    // https://stackoverflow.com/a/17340003

#if __cplusplus >= 201703L
    // C++17 folding
    (insertNode(nodes), ...);
#elif __cplusplus > 201103L
    // C++11 expansion type
    detail::ExpandType{0, (insertNode(std::forward<Ns>(nodes)), 0)...};
#endif
}

void Graph::removeNode(const Node::Pointer& n)
{
    nodes_.erase(n->uuid());
    // TODO: Remove all Node connections
}

Graph::Status Graph::status() const { return status_; }

filesystem::path Graph::cacheDir() const { return cacheDir_; }

void Graph::setCacheDir(const filesystem::path& dir) { cacheDir_ = dir; }

bool Graph::cacheEnabled() const { return cache_enabled_; }

void Graph::setEnableCache(bool enable) { cache_enabled_ = enable; }

Graph::Status Graph::update()
{
    // If already operating or in error, return
    if (status_ == Status::Updating or status_ == Status::Error) {
        return status_;
    }

    // Schedule nodes
    auto schedule = Schedule(*this);

    // Execute our schedule
    status_ = Status::Updating;
    for (auto& n : schedule) {
        auto status = n->status();
        if (status == Node::Status::Ready) {
            n->update();

            // Write to cache
            if (cache_enabled_) {
                // Write to the cache
                // TODO: Write the metadata on disk
                n->serialize(cache_enabled_, cacheDir_);
            }
        } else if (
            status == Node::Status::Waiting or
            status == Node::Status::Updating) {
            throw std::runtime_error("Node not ready but scheduled for update");
        } else if (status == Node::Status::Error) {
            throw std::runtime_error("Node update error");
        }
    }
    status_ = Status::Idle;
    return status_;
}

void Graph::Save(const filesystem::path& path, const Graph& g)
{
    namespace fs = filesystem;

    Metadata meta{
        {"software", "smgl"},
        {"type", "graph"},
        {"version", "1"},
        {"uuid", g.uuid().string()}};

    fs::path cacheRoot;
    if (g.cacheDir_.empty() or fs::weakly_canonical(path.parent_path()) ==
                                   fs::weakly_canonical(g.cacheDir_)) {
        cacheRoot = path.parent_path();
    } else {
        cacheRoot = g.cacheDir_;
        meta["cacheDir"] = g.cacheDir_.string();
    }

    Metadata connections = Metadata::array();
    for (const auto& n : g.nodes_) {
        // Write node metadata
        auto uuid = n.first.string();
        meta["nodes"].push_back(
            n.second->serialize(g.cache_enabled_, cacheRoot));

        // Accumulate connections metadata
        for (const auto& c : n.second->getOutputConnections()) {
            // If any of these are nullptr, we have problems
            assert(c.srcNode != nullptr);
            assert(c.srcPort != nullptr);
            assert(c.destNode != nullptr);
            assert(c.destPort != nullptr);

            connections.push_back(
                {{"srcNode", c.srcNode->uuid().string()},
                 {"srcPort", c.srcPort->uuid().string()},
                 {"destNode", c.destNode->uuid().string()},
                 {"destPort", c.destPort->uuid().string()}});
        }
    }
    meta["connections"] = connections;

    WriteMetadata(path, meta);
}

Graph Graph::Load(const filesystem::path& path)
{
    namespace fs = filesystem;

    // Load the metadata
    auto meta = LoadMetadata(path);

    // Validate the json file
    if (not(meta.contains("software") and meta["software"] == "smgl")) {
        throw std::runtime_error("File not generated by smgl");
    }
    if (not(meta.contains("type") and meta["type"] == "graph")) {
        throw std::runtime_error("File not a smgl Graph");
    }

    // Setup a new graph
    Graph g;

    // Load the cache directory
    if (meta.contains("cacheDir")) {
        g.cacheDir_ = meta["cacheDir"].get<std::string>();
    } else {
        g.cacheDir_ = path.parent_path();
    }

    // Load the graph UUID
    g.uuid_ = Uuid::FromString(meta["uuid"].get<std::string>());

    // Load the nodes
    for (auto& nodeMeta : meta["nodes"]) {
        // Construct the node
        auto type = nodeMeta["type"].get<std::string>();
        auto n = CreateNode(type);

        // Load the node state
        n->deserialize(nodeMeta, g.cacheDir_);

        // Add to the graph
        g.insertNode(n);
    }

    // Make connections
    for (const auto& c : meta["connections"]) {
        // Get the nodes
        auto srcNID = Uuid::FromString(c["srcNode"].get<std::string>());
        auto srcNode = g[srcNID];
        auto dstNID = Uuid::FromString(c["destNode"].get<std::string>());
        auto dstNode = g[dstNID];

        // Connect the ports
        auto srcPID = Uuid::FromString(c["srcPort"].get<std::string>());
        auto dstPID = Uuid::FromString(c["destPort"].get<std::string>());
        connect(srcNode->getOutputPort(srcPID), dstNode->getInputPort(dstPID));
    }

    return g;
}

std::vector<Node::Pointer> Graph::Schedule(const Graph& g)
{
    // Node helper struct
    struct NodeHelper {
        using Ptr = std::shared_ptr<NodeHelper>;
        Uuid uuid;
        Ptr parent;
        size_t inCns{0};
        std::vector<Uuid> cns;
        size_t start{0};
        size_t end{0};
        bool visited{false};
    };

    // TODO: Detect whether DAG

    // Setup node list
    std::unordered_map<Uuid, NodeHelper::Ptr> ns;
    for (const auto& node : g.nodes_) {
        // Make the node helper
        auto n = std::make_shared<NodeHelper>();
        n->uuid = node.first;
        n->inCns = node.second->getNumberOfInputConnections();
        // Add connections
        for (const auto& c : node.second->getOutputConnections()) {
            n->cns.push_back(c.destNode->uuid());
        }
        // Assign to the node list
        ns[node.first] = n;
    }

    // Setup DFS++
    size_t time{0};
    std::function<void(NodeHelper::Ptr&)> visit = [&time, &visit,
                                                   &ns](NodeHelper::Ptr& u) {
        if (u->visited) {
            return;
        }

        time++;
        u->start = time;
        u->visited = true;
        for (auto& c : u->cns) {
            auto v = ns[c];
            if (not v->visited) {
                v->parent = u;
                visit(v);
            }
        }
        time++;
        u->end = time;
    };

    // Run DFS++
    for (auto& n : ns) {
        if (n.second->inCns == 0) {
            visit(n.second);
        }
    }

    // Sort the results by decreasing end time
    std::vector<NodeHelper::Ptr> dfs;
    dfs.reserve(ns.size());
    for (const auto& n : ns) {
        if (not n.second->visited) {
            throw std::runtime_error("Unscheduled node: " + n.first.string());
        }
        dfs.emplace_back(n.second);
    }
    std::sort(dfs.begin(), dfs.end(), [](const auto& lhs, const auto& rhs) {
        return lhs->end > rhs->end;
    });

    // Convert to a schedule
    std::vector<Node::Pointer> schedule;
    schedule.reserve(dfs.size());
    for (const auto& n : dfs) {
        schedule.emplace_back(g[n->uuid]);
    }
    return schedule;
}

}  // namespace smgl
